package mcp

import (
	"encoding/json"
	"fmt"
	"github.com/sannysanoff/mcphost/pkg/history"
	"net/http"
	"os"
	"path/filepath"
	"reflect"
	"strings"
	"time"

	"github.com/charmbracelet/log"
	"github.com/traefik/yaegi/interp"
	"github.com/traefik/yaegi/stdlib"
	// Import the system package. After `go generate` runs, this package will contain
	// the 'Symbols' variable generated by yaegi-extract.
	systemsymbols "github.com/sannysanoff/mcphost"
)

// Agent represents a loaded agent with its interpreter and methods
type Agent interface {
	// GetSystemPrompt returns the agent's default system prompt
	GetSystemPrompt() string

	// NormalizeHistory processes and normalizes message history
	NormalizeHistory(messages []history.HistoryMessage) []history.HistoryMessage

	// Filename returns the source file name of this agent
	Filename() string

	GetTaskForModelSelection() string
}

type yaegiAgent struct {
	filename    string
	fullPath    string
	interpreter *interp.Interpreter
	lastCheck   int64
	lastModTime time.Time
}

func (a *yaegiAgent) checkAndReload() error {
	now := time.Now().Unix()
	if now-a.lastCheck < 1 {
		return nil
	}

	info, err := os.Stat(a.fullPath)
	if err != nil {
		return fmt.Errorf("failed to stat agent file: %w", err)
	}

	if info.ModTime().After(a.lastModTime) {
		// File changed - re-evaluate
		content, err := os.ReadFile(a.fullPath)
		if err != nil {
			return fmt.Errorf("failed to read agent file: %w", err)
		}

		_, err = a.interpreter.Eval(string(content))
		if err != nil {
			return fmt.Errorf("failed to evaluate agent code: %w", err)
		}

		a.lastModTime = info.ModTime()
	}

	a.lastCheck = now
	return nil
}

// prepareAgentCall handles the common logic of checking/reloading an agent
// and constructing the function name to be called.
func (a *yaegiAgent) prepareAgentCall(methodSuffix string, errorContext string) (string, error) {
	if err := a.checkAndReload(); err != nil {
		log.Error("Failed to check/reload agent for "+errorContext, "agent", a.filename, "method_suffix", methodSuffix, "error", err)
		return "", err
	}

	baseName := strings.Title(strings.TrimSuffix(filepath.Base(a.filename), ".go"))
	funcName := makePascalCase(baseName) + methodSuffix
	return funcName, nil
}

// callStringMethod calls a method on the agent that is expected to return a string.
// If the method doesn't exist, an error occurs, or it doesn't return a string, defaultValue is returned.
func (a *yaegiAgent) callStringMethod(methodSuffix string, defaultValue string) string {
	funcName, err := a.prepareAgentCall(methodSuffix, "string method '"+methodSuffix+"'")
	if err != nil {
		// Error already logged by prepareAgentCall
		return defaultValue
	}

	evalStr := fmt.Sprintf("agents.%s()", funcName)
	val, err := a.interpreter.Eval(evalStr)

	if err != nil {
		// Log if the error is not simply "symbol not found" which is an expected case for optional methods.
		if !strings.Contains(err.Error(), "undefined") && !strings.Contains(err.Error(), "not found") {
			log.Error("Failed to call agent function", "agent", a.filename, "func", funcName, "error", err)
		} else {
			log.Debug("Agent function not found or call failed, using default", "agent", a.filename, "func", funcName, "error_detail", err.Error())
		}
		return defaultValue
	}

	if val.Kind() == reflect.String {
		return val.String()
	}
	log.Warn("Agent function did not return a string, using default", "agent", a.filename, "func", funcName, "return_type", val.Kind())
	return defaultValue
}

// GetSystemPrompt calls the GetPrompt method on the agent.
func (a *yaegiAgent) GetSystemPrompt() string {
	return a.callStringMethod("GetPrompt", "")
}

// GetTaskForModelSelection calls the GetTaskForModelSelection method on the agent.
func (a *yaegiAgent) GetTaskForModelSelection() string {
	return a.callStringMethod("GetTaskForModelSelection", "default")
}

// NormalizeHistory calls the NormalizeHistory method on the agent.
func (a *yaegiAgent) NormalizeHistory(messages []history.HistoryMessage) []history.HistoryMessage {
	normalizeFuncNameRaw, err := a.prepareAgentCall("NormalizeHistory", "NormalizeHistory")
	if err != nil {
		// Error already logged by prepareAgentCall
		return messages
	}

	// The function name from prepareAgentCall might be like "DefaultNormalizeHistory".
	// We need to access it as `agents.DefaultNormalizeHistory` in the interpreter.
	targetFuncNameInScript := "agents." + normalizeFuncNameRaw

	// Get a handle to the interpreted function
	funcHandleVal, err := a.interpreter.Eval(targetFuncNameInScript)
	if err != nil {
		if strings.Contains(err.Error(), "undefined") || strings.Contains(err.Error(), "not found") {
			log.Debug("NormalizeHistory function not found in agent, using original messages.", "agent", a.filename, "func", targetFuncNameInScript)
		} else {
			log.Error("Failed to get handle for NormalizeHistory function", "agent", a.filename, "func", targetFuncNameInScript, "error", err)
		}
		return messages
	}

	if funcHandleVal.Kind() != reflect.Func {
		log.Warn("NormalizeHistory symbol in agent is not a function, using original messages.", "agent", a.filename, "func", targetFuncNameInScript, "kind", funcHandleVal.Kind())
		return messages
	}

	// Prepare arguments
	messagesVal := reflect.ValueOf(messages)
	args := []reflect.Value{messagesVal}

	// Call the interpreted function
	// Need to use a goroutine to protect against panics in Yaegi, and recover.
	var results []reflect.Value
	var callErr error

	// Setup a channel to signal completion or panic
	done := make(chan struct{})

	go func() {
		defer func() {
			if r := recover(); r != nil {
				callErr = fmt.Errorf("panic occurred during agent NormalizeHistory call: %v", r)
				log.Error("Panic recovered from Yaegi call", "agent", a.filename, "func", targetFuncNameInScript, "panic", r)
			}
			close(done)
		}()
		results = funcHandleVal.Call(args)
	}()

	// Wait for the call to complete or timeout (optional, but good for safety)
	// For now, let's wait indefinitely, but a timeout could be added.
	<-done

	if callErr != nil {
		// Error already logged by the deferred panic recovery
		return messages
	}

	// Process results
	if len(results) != 1 {
		log.Warn("NormalizeHistory function in agent did not return exactly one value, using original messages.", "agent", a.filename, "func", targetFuncNameInScript, "num_results", len(results))
		return messages
	}

	resultVal := results[0]
	if !resultVal.IsValid() {
		log.Warn("NormalizeHistory function in agent returned an invalid value, using original messages.", "agent", a.filename, "func", targetFuncNameInScript)
		return messages
	}

	// Check if the returned type is assignable to []history.HistoryMessage
	// This is a more robust check than val.Interface().([]history.HistoryMessage)
	// as it handles cases where the underlying types might be compatible but not identical.
	// However, Yaegi usually returns the exact type or an interface.

	// We expect the agent to return []history.HistoryMessage
	expectedType := reflect.TypeOf(([]history.HistoryMessage)(nil))
	if !resultVal.Type().AssignableTo(expectedType) {
		log.Warn("NormalizeHistory function returned an incompatible type.", "agent", a.filename, "func", targetFuncNameInScript, "expected_type", expectedType, "actual_type", resultVal.Type())
		return messages
	}

	if resultVal.CanInterface() {
		if processedMessages, ok := resultVal.Interface().([]history.HistoryMessage); ok {
			return processedMessages
		}
		log.Warn("NormalizeHistory function in agent returned a value that could not be asserted to []history.HistoryMessage, using original messages.", "agent", a.filename, "func", targetFuncNameInScript, "return_type", resultVal.Type())
	} else {
		log.Warn("NormalizeHistory function in agent returned an uninterfaceable value, using original messages.", "agent", a.filename, "func", targetFuncNameInScript)
	}

	return messages
}

func (a *yaegiAgent) Filename() string {
	return a.filename
}

const agentsDir = "./agents" // Assuming agents are in a directory named 'agents' relative to the running binary.

// loadAgentFromFile reads an agent file and returns an initialized Agent instance
func loadAgentFromFile(agentFilePath string) (Agent, error) {
	i := interp.New(interp.Options{})
	i.Use(stdlib.Symbols)
	i.Use(systemsymbols.Symbols)

	agentFileContent, err := os.ReadFile(agentFilePath)
	if err != nil {
		return nil, fmt.Errorf("failed to read agent file %s: %w", agentFilePath, err)
	}

	// Get file info for mod time
	info, err := os.Stat(agentFilePath)
	if err != nil {
		return nil, fmt.Errorf("failed to stat agent file %s: %w", agentFilePath, err)
	}

	// Evaluate the agent's Go code
	_, err = i.Eval(string(agentFileContent))
	if err != nil {
		return nil, fmt.Errorf("failed to evaluate agent code: %w", err)
	}

	return &yaegiAgent{
		filename:    filepath.Base(agentFilePath),
		fullPath:    agentFilePath,
		interpreter: i,
		lastCheck:   0,
		lastModTime: info.ModTime(),
	}, nil
}

func makePascalCase(name string) string {
	parts := strings.Split(name, "_")
	for i := range parts {
		if len(parts[i]) > 0 {
			parts[i] = strings.ToUpper(parts[i][:1]) + parts[i][1:]
		}
	}
	return strings.Join(parts, "")
}

// HandleListAgents discovers agents in the 'agents' directory and returns their default prompts.
func HandleListAgents(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodGet {
		http.Error(w, "Only GET method is allowed", http.StatusMethodNotAllowed)
		return
	}

	files, err := os.ReadDir(agentsDir)
	if err != nil {
		log.Error("Failed to read agents directory", "path", agentsDir, "error", err)
		http.Error(w, "Failed to read agents directory: "+err.Error(), http.StatusInternalServerError)
		return
	}

	var agents []Agent
	for _, file := range files {
		if file.IsDir() || !strings.HasSuffix(file.Name(), ".go") || file.Name() == "agents.go" {
			continue
		}

		agentFilePath := filepath.Join(agentsDir, file.Name())
		agent, err := loadAgentFromFile(agentFilePath)
		if err != nil {
			log.Warn("Failed to load agent", "file", agentFilePath, "error", err)
			continue
		}
		agents = append(agents, agent)
	}

	type agentInfo struct {
		Name          string `json:"name"`
		DefaultPrompt string `json:"default_prompt"`
	}

	var response []agentInfo
	for _, agent := range agents {
		response = append(response, agentInfo{
			Name:          strings.TrimSuffix(agent.Filename(), ".go"),
			DefaultPrompt: agent.GetSystemPrompt(),
		})
	}

	w.Header().Set("Content-Type", "application/json")
	if err := json.NewEncoder(w).Encode(response); err != nil {
		log.Error("/agents: Failed to encode agents information to JSON", "error", err)
		http.Error(w, "Failed to encode response: "+err.Error(), http.StatusInternalServerError)
	}
}

// GetDefaultAgent loads and returns the default agent implementation
func GetDefaultAgent() (Agent, error) {
	return LoadAgentByName("default")
}

// LoadAgentByName loads a specific agent by its base name (e.g., "default", "research_agent")
func LoadAgentByName(agentName string) (Agent, error) {
	if agentName == "" {
		return nil, fmt.Errorf("agent name cannot be empty")
	}
	agentFileName := agentName + ".go"
	agentFilePath := filepath.Join(agentsDir, agentFileName)

	if _, err := os.Stat(agentFilePath); os.IsNotExist(err) {
		// Attempt to create a default agent file if "default" is requested and doesn't exist.
		if agentName == "default" {
			log.Info("Default agent file not found, creating one.", "path", agentFilePath)
			defaultContent := `package agents

// DefaultGetPrompt provides a basic system prompt.
func DefaultGetPrompt() string {
	return "You are a helpful assistant."
}

// DefaultGetTaskForModelSelection specifies the default task for model selection.
func DefaultGetTaskForModelSelection() string {
	return "general_assistance"
}

// DefaultNormalizeHistory is a placeholder and returns messages as is.
// func DefaultNormalizeHistory(messages []history.HistoryMessage) []history.HistoryMessage {
// 	return messages
// }
`
			if errWrite := os.WriteFile(agentFilePath, []byte(defaultContent), 0644); errWrite != nil {
				return nil, fmt.Errorf("failed to create default agent file '%s': %w", agentFilePath, errWrite)
			}
			log.Info("Successfully created default agent file.", "path", agentFilePath)
			// Fall through to load the newly created file.
		} else {
			return nil, fmt.Errorf("agent file '%s' not found in '%s': %w", agentFileName, agentsDir, err)
		}
	} else if err != nil {
		return nil, fmt.Errorf("error checking agent file '%s': %w", agentFilePath, err)
	}

	return loadAgentFromFile(agentFilePath)
}
