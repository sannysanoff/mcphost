package mcp

import (
	"encoding/json"
	"fmt"
	"github.com/sannysanoff/mcphost/pkg/history"
	"github.com/sannysanoff/mcphost/pkg/system"
	"net/http"
	"os"
	"path/filepath"
	"strings"
	"time"

	"github.com/charmbracelet/log"
	"github.com/traefik/yaegi/interp"
	"github.com/traefik/yaegi/stdlib"
	// Import the system package. After `go generate` runs, this package will contain
	// the 'Symbols' variable generated by yaegi-extract.
	systemsymbols "github.com/sannysanoff/mcphost"
)

// Agent represents a loaded agent with its interpreter and methods
type Agent interface {
	// GetSystemPrompt returns the agent's default system prompt
	GetSystemPrompt() string

	// NormalizeHistory processes and normalizes message history
	NormalizeHistory(messages []history.HistoryMessage) []history.HistoryMessage

	// Filename returns the source file name of this agent
	Filename() string

	GetTaskForModelSelection() string
}

type yaegiAgent struct {
	filename       string
	fullPath       string
	interpreter    *interp.Interpreter
	lastCheck      int64
	lastModTime    time.Time
	implementation *system.AgentImplementationBase
}

func makePascalCase(name string) string {
	parts := strings.Split(name, "_")
	for i := range parts {
		if len(parts[i]) > 0 {
			parts[i] = strings.ToUpper(parts[i][:1]) + parts[i][1:]
		}
	}
	return strings.Join(parts, "")
}

// ensureImplementationReady checks if the agent script needs to be (re-)evaluated and
// if the agent implementation object needs to be (re-)loaded.
// It handles initial loading and reloading upon file modification.
// Agent scripts are expected to define a "PascalCaseAgentNameNew() *system.AgentImplementationBase" function.
func (a *yaegiAgent) ensureImplementationReady() error {
	now := time.Now().Unix()
	isInitialLoad := a.implementation == nil
	scriptNeedsReEval := false
	var newModTimeIfReEval time.Time

	// Check for file modification at most once per second.
	if now-a.lastCheck >= 1 {
		a.lastCheck = now
		info, err := os.Stat(a.fullPath)
		if err != nil {
			a.implementation = nil // Invalidate
			return fmt.Errorf("failed to stat agent file %s: %w", a.fullPath, err)
		}
		if info.ModTime().After(a.lastModTime) {
			log.Info("Agent file changed, scheduling re-evaluation.", "agent", a.filename, "oldModTime", a.lastModTime, "newModTime", info.ModTime())
			scriptNeedsReEval = true
			newModTimeIfReEval = info.ModTime()
		}
	}

	// If it's an initial load or script needs re-evaluation, evaluate the script content.
	if isInitialLoad || scriptNeedsReEval {
		log.Debug("Evaluating agent script content.", "agent", a.filename, "initial", isInitialLoad, "reEval", scriptNeedsReEval)
		content, err := os.ReadFile(a.fullPath)
		if err != nil {
			a.implementation = nil // Invalidate
			return fmt.Errorf("failed to read agent file %s for evaluation: %w", a.fullPath, err)
		}

		_, err = a.interpreter.Eval(string(content))
		if err != nil {
			a.implementation = nil // Invalidate
			return fmt.Errorf("failed to evaluate agent script %s: %w", a.filename, err)
		}

		if scriptNeedsReEval {
			a.lastModTime = newModTimeIfReEval // Update modTime after successful re-evaluation
		}
		// For initialLoad, lastModTime was set by the caller (loadAgentFromFile).
		log.Debug("Agent script content evaluated successfully.", "agent", a.filename)
	}

	// If implementation is nil (initial load) or script was re-evaluated, then (re)load the implementation object.
	if isInitialLoad || scriptNeedsReEval {
		log.Debug("Attempting to load/reload agent implementation object.", "agent", a.filename)
		agentBaseName := strings.TrimSuffix(filepath.Base(a.filename), ".go")
		constructorName := makePascalCase(agentBaseName) + "New"

		val, err := a.interpreter.Eval(constructorName + "()")
		if err != nil {
			a.implementation = nil
			return fmt.Errorf("failed to call %s in agent script %s: %w. Ensure %s exists and returns *system.AgentImplementationBase.", constructorName, a.filename, err, constructorName)
		}

		impl, ok := val.Interface().(*system.AgentImplementationBase)
		if !ok {
			a.implementation = nil
			return fmt.Errorf("%s in agent script %s did not return *system.AgentImplementationBase, got %T", constructorName, a.filename, val.Interface())
		}
		if impl == nil {
			a.implementation = nil
			return fmt.Errorf("%s in agent script %s returned nil", constructorName, a.filename)
		}
		a.implementation = impl
		log.Info("Agent implementation object loaded/reloaded successfully.", "agent", a.filename)
	} else if a.implementation == nil {
		// This case should ideally not be reached if logic is correct.
		return fmt.Errorf("internal error: agent implementation is nil for %s despite no load/re-eval trigger", a.filename)
	}
	return nil
}

// GetSystemPrompt retrieves the system prompt from the agent's implementation.
func (a *yaegiAgent) GetSystemPrompt() string {
	if err := a.ensureImplementationReady(); err != nil {
		log.Error("Failed to get agent system prompt due to implementation error", "agent", a.filename, "error", err)
		return "" // Default value on error
	}
	// Assumes system.AgentImplementationBase.GetSystemPrompt() handles nil receiver gracefully or GetImplementation never returns nil on success.
	return a.implementation.GetSystemPrompt()
}

// GetTaskForModelSelection retrieves the task for model selection from the agent's implementation.
func (a *yaegiAgent) GetTaskForModelSelection() string {
	if err := a.ensureImplementationReady(); err != nil {
		log.Error("Failed to get agent task for model selection due to implementation error", "agent", a.filename, "error", err)
		return "default" // Default value on error
	}
	return a.implementation.GetTaskForModelSelection()
}

// NormalizeHistory delegates to the agent's implementation.
func (a *yaegiAgent) NormalizeHistory(messages []history.HistoryMessage) []history.HistoryMessage {
	if err := a.ensureImplementationReady(); err != nil {
		log.Error("Failed to normalize history due to agent implementation error", "agent", a.filename, "error", err)
		return messages // Return original messages on error
	}
	// Assumes system.AgentImplementationBase.NormalizeHistory() handles nil receiver or nil NormalizeHistoryFunc gracefully.
	return a.implementation.NormalizeHistory(messages)
}

func (a *yaegiAgent) Filename() string {
	return a.filename
}

const agentsDir = "./agents" // Assuming agents are in a directory named 'agents' relative to the running binary.

// loadAgentFromFile reads an agent file and returns an initialized Agent instance
func loadAgentFromFile(agentFilePath string) (Agent, error) {
	i := interp.New(interp.Options{})
	i.Use(stdlib.Symbols)
	i.Use(systemsymbols.Symbols)

	// Get file info for initial mod time
	info, err := os.Stat(agentFilePath)
	if err != nil {
		return nil, fmt.Errorf("failed to stat agent file %s: %w", agentFilePath, err)
	}

	agent := &yaegiAgent{
		filename:       filepath.Base(agentFilePath),
		fullPath:       agentFilePath,
		interpreter:    i,
		lastCheck:      time.Now().Unix(), // Initialize lastCheck
		lastModTime:    info.ModTime(),    // Set initial modTime
		implementation: nil,               // Implementation starts as nil, to be loaded by ensureImplementationReady
	}

	// ensureImplementationReady will handle the initial script evaluation and implementation loading
	if err := agent.ensureImplementationReady(); err != nil {
		// Error is already formatted by ensureImplementationReady or one of its callees
		return nil, err
	}

	// Log success after ensureImplementationReady has done its work.
	// Specifics of what was done (initial load vs reload) are logged within ensureImplementationReady.
	log.Info("Agent loaded successfully", "file", agentFilePath)
	return agent, nil
}

// HandleListAgents discovers agents in the 'agents' directory and returns their default prompts.
func HandleListAgents(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodGet {
		http.Error(w, "Only GET method is allowed", http.StatusMethodNotAllowed)
		return
	}

	files, err := os.ReadDir(agentsDir)
	if err != nil {
		log.Error("Failed to read agents directory", "path", agentsDir, "error", err)
		http.Error(w, "Failed to read agents directory: "+err.Error(), http.StatusInternalServerError)
		return
	}

	var agents []Agent
	for _, file := range files {
		if file.IsDir() || !strings.HasSuffix(file.Name(), ".go") || file.Name() == "agents.go" {
			continue
		}

		agentFilePath := filepath.Join(agentsDir, file.Name())
		agent, err := loadAgentFromFile(agentFilePath)
		if err != nil {
			log.Warn("Failed to load agent", "file", agentFilePath, "error", err)
			continue
		}
		agents = append(agents, agent)
	}

	type agentInfo struct {
		Name          string `json:"name"`
		DefaultPrompt string `json:"default_prompt"`
	}

	var response []agentInfo
	for _, agent := range agents {
		response = append(response, agentInfo{
			Name:          strings.TrimSuffix(agent.Filename(), ".go"),
			DefaultPrompt: agent.GetSystemPrompt(),
		})
	}

	w.Header().Set("Content-Type", "application/json")
	if err := json.NewEncoder(w).Encode(response); err != nil {
		log.Error("/agents: Failed to encode agents information to JSON", "error", err)
		http.Error(w, "Failed to encode response: "+err.Error(), http.StatusInternalServerError)
	}
}

// GetDefaultAgent loads and returns the default agent implementation
func GetDefaultAgent() (Agent, error) {
	return LoadAgentByName("default")
}

// LoadAgentByName loads a specific agent by its base name (e.g., "default", "research_agent")
func LoadAgentByName(agentName string) (Agent, error) {
	if agentName == "" {
		return nil, fmt.Errorf("agent name cannot be empty")
	}
	agentFileName := agentName + ".go"
	agentFilePath := filepath.Join(agentsDir, agentFileName)

	if _, err := os.Stat(agentFilePath); os.IsNotExist(err) {
		// Attempt to create a default agent file if "default" is requested and doesn't exist.
		if agentName == "default" {
			log.Info("Default agent file not found, creating one.", "path", agentFilePath)
			defaultContent := `package agents

import "github.com/sannysanoff/mcphost/pkg/system"
import "github.com/sannysanoff/mcphost/pkg/history"

// DefaultNew provides the agent's core logic and configuration.
// This function is called by MCPHost to obtain the agent's behavior for the "default" agent.
// Replace "DefaultNew" with "YourAgentNameNew" for other agent files, matching the file name.
func DefaultNew() *system.AgentImplementationBase {
	return &system.AgentImplementationBase{
		SystemPrompt: "You are a helpful assistant.",
		TaskForModel: "general_assistance",
		// NormalizeHistoryFunc is optional. If nil, messages are used as is.
		// You can define custom normalization logic here if needed.
		NormalizeHistoryFunc: func(messages []history.HistoryMessage) []history.HistoryMessage {
			// Default behavior: return messages as is.
			// Add custom normalization logic if required for this agent.
			// For example, pruning, reformatting, or adding specific context.
			return messages
		},
	}
}
`
			// Determine the correct constructor name based on the agentName
			pascalAgentName := makePascalCase(agentName)
			constructorFunc := pascalAgentName + "New"
			finalDefaultContent := strings.Replace(defaultContent, "DefaultNew", constructorFunc, 1)

			if errWrite := os.WriteFile(agentFilePath, []byte(finalDefaultContent), 0644); errWrite != nil {
				return nil, fmt.Errorf("failed to create default agent file '%s': %w", agentFilePath, errWrite)
			}
			log.Info("Successfully created default agent file.", "path", agentFilePath)
			// Fall through to load the newly created file.
		} else {
			return nil, fmt.Errorf("agent file '%s' not found in '%s': %w", agentFileName, agentsDir, err)
		}
	} else if err != nil {
		return nil, fmt.Errorf("error checking agent file '%s': %w", agentFilePath, err)
	}

	return loadAgentFromFile(agentFilePath)
}
