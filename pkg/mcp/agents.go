package mcp

import (
	"encoding/json"
	"fmt"
	"net/http"
	"os"
	"path/filepath"
	"reflect"
	"strings"

	"github.com/charmbracelet/log"
	"github.com/traefik/yaegi/interp"
	"github.com/traefik/yaegi/stdlib"
	// Import the system package. After `go generate` runs, this package will contain
	// the 'Symbols' variable generated by yaegi-extract.
	systemsymbols "github.com/sannysanoff/mcphost"
)

// AgentInfo holds information about a discovered agent.
type AgentInfo struct {
	Name          string `json:"name"`
	DefaultPrompt string `json:"default_prompt"`
}

type Agent interface {
	GetSystemPrompt() string
}

const agentsDir = "./agents" // Assuming agents are in a directory named 'agents' relative to the running binary.

// getAgentInfoFromFile reads an agent file, evaluates it using the provided Yaegi interpreter,
// and extracts its name and default prompt.
func getAgentInfoFromFile(agentFilePath string, i *interp.Interpreter) (*AgentInfo, error) {
	agentName := strings.TrimSuffix(filepath.Base(agentFilePath), ".go")
	// Construct the conventional function name, e.g., "default" -> "DefaultGetPrompt"
	// Yaegi expects functions to be capitalized for export.
	baseName := strings.Title(agentName) // Ensures first letter is capitalized
	promptFuncName := makePascalCase(baseName) + "GetPrompt"

	log.Debug("Processing agent file", "path", agentFilePath, "agentName", agentName, "promptFunc", promptFuncName)

	agentFileContent, err := os.ReadFile(agentFilePath)
	if err != nil {
		return nil, fmt.Errorf("failed to read agent file %s: %w", agentFilePath, err)
	}

	// Evaluate the agent's Go code. Agent files are expected to be in `package agents`.
	_, err = i.Eval(string(agentFileContent))
	if err != nil {
		return nil, fmt.Errorf("failed to evaluate agent code with Yaegi for file %s: %w", agentFilePath, err)
	}

	// Call the GetPrompt function (e.g., agents.DefaultGetPrompt())
	// Yaegi symbols are typically package-qualified.
	evalStr := fmt.Sprintf("agents.%s()", promptFuncName)
	val, err := i.Eval(evalStr)
	if err != nil {
		return nil, fmt.Errorf("failed to call prompt function via Yaegi for file %s (eval string: %s): %w", agentFilePath, evalStr, err)
	}

	// Extract the prompt string
	if val.Kind() == reflect.String {
		prompt := val.String()
		log.Debug("Successfully retrieved prompt", "agent", agentName, "prompt", prompt)
		retval := &AgentInfo{
			Name:          agentName,
			DefaultPrompt: prompt,
		}
		return retval, nil
	}

	return nil, fmt.Errorf("prompt function %s in file %s did not return a string, got type: %s", promptFuncName, agentFilePath, val.Kind().String())
}

func makePascalCase(name string) string {
	parts := strings.Split(name, "_")
	for i := range parts {
		if len(parts[i]) > 0 {
			parts[i] = strings.ToUpper(parts[i][:1]) + parts[i][1:]
		}
	}
	return strings.Join(parts, "")
}

// HandleListAgents discovers agents in the 'agents' directory and returns their default prompts.
func HandleListAgents(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodGet {
		http.Error(w, "Only GET method is allowed", http.StatusMethodNotAllowed)
		return
	}

	files, err := os.ReadDir(agentsDir)
	if err != nil {
		log.Error("Failed to read agents directory", "path", agentsDir, "error", err)
		http.Error(w, "Failed to read agents directory: "+err.Error(), http.StatusInternalServerError)
		return
	}

	var agentsInfoList []AgentInfo
	i := interp.New(interp.Options{})
	i.Use(stdlib.Symbols)        // Provide access to Go standard library symbols
	i.Use(systemsymbols.Symbols) // Provide access to symbols from github.com/mark3labs/mcphost

	for _, file := range files {
		if file.IsDir() || !strings.HasSuffix(file.Name(), ".go") || file.Name() == "agents.go" {
			// Skip directories, non-Go files, and this handler file itself
			continue
		}

		agentFilePath := filepath.Join(agentsDir, file.Name())
		info, err := getAgentInfoFromFile(agentFilePath, i)
		if err != nil {
			log.Warn("Failed to get agent info", "file", agentFilePath, "error", err)
			continue // Skip this agent
		}
		agentsInfoList = append(agentsInfoList, *info)
	}

	w.Header().Set("Content-Type", "application/json")
	if err := json.NewEncoder(w).Encode(agentsInfoList); err != nil {
		log.Error("/agents: Failed to encode agents information to JSON", "error", err)
		http.Error(w, "Failed to encode response: "+err.Error(), http.StatusInternalServerError)
	}
}

// GetDefaultAgentSystemPrompt attempts to load the system prompt from the 'default.go' agent.
// It returns the prompt string or an error if the agent or prompt cannot be loaded.
func GetDefaultAgentSystemPrompt() (string, error) {
	defaultAgentFileName := "default.go"
	defaultAgentFilePath := filepath.Join(agentsDir, defaultAgentFileName)

	if _, err := os.Stat(defaultAgentFilePath); os.IsNotExist(err) {
		return "", fmt.Errorf("default agent file '%s' not found: %w", defaultAgentFilePath, err)
	}

	i := interp.New(interp.Options{})
	i.Use(stdlib.Symbols)        // Provide access to Go standard library symbols
	i.Use(systemsymbols.Symbols) // Provide access to symbols from github.com/mark3labs/mcphost

	agentInfo, err := getAgentInfoFromFile(defaultAgentFilePath, i)
	if err != nil {
		return "", fmt.Errorf("failed to get info from default agent file '%s': %w", defaultAgentFilePath, err)
	}

	if agentInfo == nil {
		return "", fmt.Errorf("no agent info returned from default agent file '%s'", defaultAgentFilePath)
	}

	return agentInfo.DefaultPrompt, nil
}
