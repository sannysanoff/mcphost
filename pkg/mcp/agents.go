package mcp

import (
	"encoding/json"
	"fmt"
	"github.com/sannysanoff/mcphost/pkg/history"
	"github.com/sannysanoff/mcphost/pkg/system"
	"net/http"
	"os"
	"path/filepath"
	"reflect"
	"strings"
	"time"

	"github.com/charmbracelet/log"
	"github.com/traefik/yaegi/interp"
	"github.com/traefik/yaegi/stdlib"
	// Import the system package. After `go generate` runs, this package will contain
	// the 'Symbols' variable generated by yaegi-extract.
	systemsymbols "github.com/sannysanoff/mcphost"
)

// Agent represents a loaded agent with its interpreter and methods
type Agent interface {
	// GetSystemPrompt returns the agent's default system prompt
	GetSystemPrompt() string

	// NormalizeHistory processes and normalizes message history
	NormalizeHistory(messages []history.HistoryMessage) []history.HistoryMessage

	// Filename returns the source file name of this agent
	Filename() string

	GetTaskForModelSelection() string
}

type yaegiAgent struct {
	filename       string
	fullPath    string
	interpreter *interp.Interpreter
	lastCheck   int64
	lastModTime time.Time
	agentImpl   Agent // Holds the instantiated agent implementation
}

// reloadAgentScript evaluates the agent script and re-initializes the agentImpl.
func (a *yaegiAgent) reloadAgentScript() error {
	content, err := os.ReadFile(a.fullPath)
	if err != nil {
		return fmt.Errorf("failed to read agent file %s: %w", a.fullPath, err)
	}

	// Re-evaluate the script in the existing interpreter
	_, err = a.interpreter.Eval(string(content))
	if err != nil {
		return fmt.Errorf("failed to evaluate agent code from %s: %w", a.fullPath, err)
	}

	// Re-initialize the agent implementation by calling its "New" function
	agentName := strings.TrimSuffix(filepath.Base(a.filename), ".go")
	newFuncName := "agents." + makePascalCase(agentName) + "New"

	val, err := a.interpreter.Eval(newFuncName + "()")
	if err != nil {
		return fmt.Errorf("failed to call %s for agent %s: %w", newFuncName, a.filename, err)
	}

	impl, ok := val.Interface().(Agent)
	if !ok {
		return fmt.Errorf("%s for agent %s did not return a compatible Agent implementation (got %T)", newFuncName, a.filename, val.Interface())
	}
	if impl == nil {
		return fmt.Errorf("%s for agent %s returned a nil Agent implementation", newFuncName, a.filename)
	}

	a.agentImpl = impl
	log.Info("Agent implementation reloaded successfully", "agent", a.filename, "new_func", newFuncName)
	return nil
}

func (a *yaegiAgent) checkAndReload() error {
	now := time.Now().Unix()
	if now-a.lastCheck < 1 { // Check at most once per second
		return nil
	}
	a.lastCheck = now

	info, err := os.Stat(a.fullPath)
	if err != nil {
		return fmt.Errorf("failed to stat agent file %s: %w", a.fullPath, err)
	}

	if info.ModTime().After(a.lastModTime) {
		log.Info("Agent file changed, attempting reload...", "agent", a.filename, "path", a.fullPath)
		if err := a.reloadAgentScript(); err != nil {
			// Log the error but don't necessarily prevent the agent from using the old impl if reload fails.
			// Or, decide on a stricter policy (e.g., nil out agentImpl or return error).
			// For now, log and continue with potentially stale implementation if reload fails.
			log.Error("Failed to reload agent script", "agent", a.filename, "error", err)
			// Return the error so callers can decide how to handle a failed reload.
			return fmt.Errorf("failed to reload agent script %s: %w", a.filename, err)
		}
		a.lastModTime = info.ModTime()
	}
	return nil
}

// GetSystemPrompt returns the system prompt from the instantiated agent.
func (a *yaegiAgent) GetSystemPrompt() string {
	if err := a.checkAndReload(); err != nil {
		log.Error("Agent reload check failed for GetSystemPrompt", "agent", a.filename, "error", err)
		// Fallback or default behavior
		if a.agentImpl != nil {
			log.Warn("Using potentially stale agent implementation for GetSystemPrompt due to reload error", "agent", a.filename)
			return a.agentImpl.GetSystemPrompt()
		}
		return "You are a helpful assistant (fallback due to agent error)."
	}
	if a.agentImpl == nil { // Should ideally be caught by loadAgentFromFile
		log.Error("Agent implementation is nil for GetSystemPrompt", "agent", a.filename)
		return "You are a helpful assistant (fallback due to nil agent)."
	}
	return a.agentImpl.GetSystemPrompt()
}

// GetTaskForModelSelection returns the task for model selection from the instantiated agent.
func (a *yaegiAgent) GetTaskForModelSelection() string {
	if err := a.checkAndReload(); err != nil {
		log.Error("Agent reload check failed for GetTaskForModelSelection", "agent", a.filename, "error", err)
		if a.agentImpl != nil {
			log.Warn("Using potentially stale agent implementation for GetTaskForModelSelection due to reload error", "agent", a.filename)
			return a.agentImpl.GetTaskForModelSelection()
		}
		return "default" // Fallback
	}
	if a.agentImpl == nil {
		log.Error("Agent implementation is nil for GetTaskForModelSelection", "agent", a.filename)
		return "default" // Fallback
	}
	return a.agentImpl.GetTaskForModelSelection()
}

// NormalizeHistory processes messages using the instantiated agent's logic.
func (a *yaegiAgent) NormalizeHistory(messages []history.HistoryMessage) []history.HistoryMessage {
	if err := a.checkAndReload(); err != nil {
		log.Error("Agent reload check failed for NormalizeHistory", "agent", a.filename, "error", err)
		if a.agentImpl != nil {
			log.Warn("Using potentially stale agent implementation for NormalizeHistory due to reload error", "agent", a.filename)
			return a.agentImpl.NormalizeHistory(messages)
		}
		return messages // Fallback: return original messages
	}
	if a.agentImpl == nil {
		log.Error("Agent implementation is nil for NormalizeHistory", "agent", a.filename)
		return messages // Fallback: return original messages
	}
	return a.agentImpl.NormalizeHistory(messages)
}

func (a *yaegiAgent) Filename() string {
	return a.filename
}

const agentsDir = "./agents" // Assuming agents are in a directory named 'agents' relative to the running binary.

// loadAgentFromFile reads an agent file and returns an initialized Agent instance
func loadAgentFromFile(agentFilePath string) (Agent, error) {
	i := interp.New(interp.Options{})
	i.Use(stdlib.Symbols)
	i.Use(systemsymbols.Symbols)

	agentFileContent, err := os.ReadFile(agentFilePath)
	if err != nil {
		return nil, fmt.Errorf("failed to read agent file %s: %w", agentFilePath, err)
	}

	// Evaluate the agent's Go code first to define types and functions
	_, err = i.Eval(string(agentFileContent))
	if err != nil {
		return nil, fmt.Errorf("failed to evaluate agent code from %s: %w", agentFilePath, err)
	}

	// Now, call the "New" function to get an agent instance
	agentName := strings.TrimSuffix(filepath.Base(agentFilePath), ".go")
	newFuncName := "agents." + makePascalCase(agentName) + "New" // e.g., agents.DefaultNew

	val, err := i.Eval(newFuncName + "()") // Call the New function
	if err != nil {
		return nil, fmt.Errorf("failed to call %s for agent %s: %w", newFuncName, agentFilePath, err)
	}

	impl, ok := val.Interface().(Agent) // Assert to the mcp.Agent interface
	if !ok {
		return nil, fmt.Errorf("%s for agent %s did not return a compatible Agent implementation (got %T, expected mcp.Agent)", newFuncName, agentFilePath, val.Interface())
	}
	if impl == nil {
		return nil, fmt.Errorf("%s for agent %s returned a nil Agent implementation", newFuncName, agentFilePath)
	}

	// Get file info for mod time
	info, err := os.Stat(agentFilePath)
	if err != nil {
		return nil, fmt.Errorf("failed to stat agent file %s: %w", agentFilePath, err)
	}

	return &yaegiAgent{
		filename:    filepath.Base(agentFilePath),
		fullPath:    agentFilePath,
		interpreter: i,
		agentImpl:   impl, // Store the instantiated agent
		lastCheck:   0,    // Force check on first use after load
		lastModTime: info.ModTime(),
	}, nil
}

func makePascalCase(name string) string {
	parts := strings.Split(name, "_")
	for i := range parts {
		if len(parts[i]) > 0 {
			parts[i] = strings.ToUpper(parts[i][:1]) + parts[i][1:]
		}
	}
	return strings.Join(parts, "")
}

// HandleListAgents discovers agents in the 'agents' directory and returns their default prompts.
func HandleListAgents(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodGet {
		http.Error(w, "Only GET method is allowed", http.StatusMethodNotAllowed)
		return
	}

	files, err := os.ReadDir(agentsDir)
	if err != nil {
		log.Error("Failed to read agents directory", "path", agentsDir, "error", err)
		http.Error(w, "Failed to read agents directory: "+err.Error(), http.StatusInternalServerError)
		return
	}

	var agents []Agent
	for _, file := range files {
		if file.IsDir() || !strings.HasSuffix(file.Name(), ".go") || file.Name() == "agents.go" {
			continue
		}

		agentFilePath := filepath.Join(agentsDir, file.Name())
		agent, err := loadAgentFromFile(agentFilePath)
		if err != nil {
			log.Warn("Failed to load agent", "file", agentFilePath, "error", err)
			continue
		}
		agents = append(agents, agent)
	}

	type agentInfo struct {
		Name          string `json:"name"`
		DefaultPrompt string `json:"default_prompt"`
	}

	var response []agentInfo
	for _, agent := range agents {
		response = append(response, agentInfo{
			Name:          strings.TrimSuffix(agent.Filename(), ".go"),
			DefaultPrompt: agent.GetSystemPrompt(),
		})
	}

	w.Header().Set("Content-Type", "application/json")
	if err := json.NewEncoder(w).Encode(response); err != nil {
		log.Error("/agents: Failed to encode agents information to JSON", "error", err)
		http.Error(w, "Failed to encode response: "+err.Error(), http.StatusInternalServerError)
	}
}

// GetDefaultAgent loads and returns the default agent implementation
func GetDefaultAgent() (Agent, error) {
	return LoadAgentByName("default")
}

// LoadAgentByName loads a specific agent by its base name (e.g., "default", "research_agent")
func LoadAgentByName(agentName string) (Agent, error) {
	if agentName == "" {
		return nil, fmt.Errorf("agent name cannot be empty")
	}
	agentFileName := agentName + ".go"
	agentFilePath := filepath.Join(agentsDir, agentFileName)

	if _, err := os.Stat(agentFilePath); os.IsNotExist(err) {
		// Attempt to create a default agent file if "default" is requested and doesn't exist.
		if agentName == "default" {
			log.Info("Default agent file not found, creating one.", "path", agentFilePath)
			defaultContent := `package agents

import (
	"fmt"
	"github.com/sannysanoff/mcphost/pkg/history" // Needed if NormalizeHistory is overridden
	"github.com/sannysanoff/mcphost/pkg/system"
	"time"
)

// DefaultAgent is the structure for the default agent.
// It embeds system.AgentImplementationBase to inherit default behaviors.
type DefaultAgent struct {
	system.AgentImplementationBase
}

// GetSystemPrompt overrides the base system prompt.
func (a *DefaultAgent) GetSystemPrompt() string {
	return fmt.Sprintf("You are a helpful assistant (auto-generated default agent). Today is %s.", time.Now().Format("January 2, 2006"))
}

// NormalizeHistory can be overridden if specific normalization logic is needed.
// By default, it uses the behavior from system.AgentImplementationBase.
// func (a *DefaultAgent) NormalizeHistory(messages []history.HistoryMessage) []history.HistoryMessage {
//	 // Example: return a.AgentImplementationBase.NormalizeHistory(messages)
//	 return messages
// }

// GetTaskForModelSelection can be overridden if needed.
// By default, it uses the behavior from system.AgentImplementationBase.
// func (a *DefaultAgent) GetTaskForModelSelection() string {
//	 return "custom_task_for_default"
// }

// DefaultNew is the constructor for DefaultAgent.
// It must return a type that satisfies the mcp.Agent interface.
func DefaultNew() *DefaultAgent {
	return &DefaultAgent{}
}
`
			if errWrite := os.WriteFile(agentFilePath, []byte(defaultContent), 0644); errWrite != nil {
				return nil, fmt.Errorf("failed to create default agent file '%s': %w", agentFilePath, errWrite)
			}
			log.Info("Successfully created default agent file.", "path", agentFilePath)
			// Fall through to load the newly created file.
		} else {
			return nil, fmt.Errorf("agent file '%s' not found in '%s': %w", agentFileName, agentsDir, err)
		}
	} else if err != nil {
		return nil, fmt.Errorf("error checking agent file '%s': %w", agentFilePath, err)
	}

	return loadAgentFromFile(agentFilePath)
}
