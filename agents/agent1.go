package agents

import (
	"encoding/json"
	"fmt"
	"net/http"
	"os"
	"path/filepath"
	"reflect"
	"strings"

	"github.com/charmbracelet/log"
	"github.com/traefik/yaegi/interp"
	"github.com/traefik/yaegi/stdlib"
	// Import the system package. After `go generate` runs, this package will contain
	// the 'Symbols' variable generated by yaegi-extract.
	systemsymbols "github.com/mark3labs/mcphost"
)

// AgentInfo holds information about a discovered agent.
type AgentInfo struct {
	Name          string `json:"name"`
	DefaultPrompt string `json:"default_prompt"`
}

// HandleListAgents discovers agents in the 'agents' directory and returns their default prompts.
func HandleListAgents(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodGet {
		http.Error(w, "Only GET method is allowed", http.StatusMethodNotAllowed)
		return
	}

	agentsDir := "./agents" // Assuming agents are in a directory named 'agents' relative to the running binary.
	// This might need to be configurable or determined more robustly.

	files, err := os.ReadDir(agentsDir)
	if err != nil {
		log.Error("Failed to read agents directory", "path", agentsDir, "error", err)
		http.Error(w, "Failed to read agents directory: "+err.Error(), http.StatusInternalServerError)
		return
	}

	var agentsInfo []AgentInfo
	i := interp.New(interp.Options{})
	i.Use(stdlib.Symbols) // Provide access to standard library symbols

	// Provide access to symbols from github.com/mark3labs/mcphost/pkg/system
	// The 'Symbols' var is expected to be generated by 'yaegi-extract' in the 'systemsymbols' package.
	i.Use(systemsymbols.Symbols)

	for _, file := range files {
		if file.IsDir() || !strings.HasSuffix(file.Name(), ".go") || file.Name() == "agents.go" {
			// Skip directories, non-Go files, and the handler file itself
			continue
		}

		agentFilePath := filepath.Join(agentsDir, file.Name())
		agentName := strings.TrimSuffix(file.Name(), ".go")
		// Construct the conventional function name, e.g., "Agent1" -> "Agent1_GetPrompt"
		// Yaegi expects functions to be capitalized for export.
		baseName := strings.Title(agentName) // Ensures first letter is capitalized, e.g., "agent1" -> "Agent1"
		promptFuncName := baseName + "_GetPrompt"

		log.Debug("Processing agent file", "path", agentFilePath, "agentName", agentName, "promptFunc", promptFuncName)

		agentFileContent, err := os.ReadFile(agentFilePath)
		if err != nil {
			log.Error("Failed to read agent file", "path", agentFilePath, "error", err)
			continue // Skip this agent
		}

		// Evaluate the agent's Go code
		// The agent files are `package agents`
		_, err = i.Eval(string(agentFileContent))
		if err != nil {
			log.Error("Failed to evaluate agent code with Yaegi", "file", agentFilePath, "error", err)
			continue // Skip this agent
		}

		// Call the GetPrompt function (e.g., agents.Agent1_GetPrompt())
		// Note: Yaegi symbols are typically package-qualified.
		evalStr := fmt.Sprintf("agents.%s()", promptFuncName)
		val, err := i.Eval(evalStr)
		if err != nil {
			log.Error("Failed to call prompt function via Yaegi", "file", agentFilePath, "eval", evalStr, "error", err)
			continue // Skip this agent
		}

		// Extract the prompt string
		if val.Kind() == reflect.String {
			prompt := val.String()
			agentsInfo = append(agentsInfo, AgentInfo{
				Name:          agentName,
				DefaultPrompt: prompt,
			})
			log.Debug("Successfully retrieved prompt", "agent", agentName, "prompt", prompt)
		} else {
			log.Warn("Prompt function did not return a string", "file", agentFilePath, "got_type", val.Kind().String())
		}
	}

	w.Header().Set("Content-Type", "application/json")
	if err := json.NewEncoder(w).Encode(agentsInfo); err != nil {
		log.Error("/agents: Failed to encode agents information to JSON", "error", err)
		http.Error(w, "Failed to encode response: "+err.Error(), http.StatusInternalServerError)
	}
}
